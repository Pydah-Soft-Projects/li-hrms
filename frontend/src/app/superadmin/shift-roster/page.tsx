'use client';

import React, { useEffect, useMemo, useState, useCallback } from 'react';
import { api } from '@/lib/api';
import { toast } from 'react-hot-toast';
import { format, parseISO } from 'date-fns';
import * as XLSX from 'xlsx';

import { Holiday, HolidayGroup, Shift, Employee } from '@/lib/api';
import {
  LayoutGrid,
  Save,
  Download,
  Settings2,
  CheckCircle2
} from 'lucide-react';

import {
  RosterCell,
  RosterState,
  AssignmentSummaryItem
} from './types';

import {
  checkGroupApplicability,
  formatMonthInput,
  getMonthDays,
  shiftLabel
} from './utils';

// Import Modular Components
import RosterFilters from './components/RosterFilters';
import SearchSection from './components/SearchSection';
import QuickAssignSection from './components/QuickAssignSection';
import RosterGrid from './components/RosterGrid';
import AssignmentsView from './components/AssignmentsView';
import WeekOffModal from './components/WeekOffModal';

const ROSTER_LIMIT = 50;

export default function RosterPage() {
  const [month, setMonth] = useState(formatMonthInput(new Date()));
  const [strict, setStrict] = useState(false);
  const [shifts, setShifts] = useState<Shift[]>([]);
  const [employees, setEmployees] = useState<Employee[]>([]);
  const [divisions, setDivisions] = useState<any[]>([]);
  const [departments, setDepartments] = useState<any[]>([]);
  const [selectedDivision, setSelectedDivision] = useState<string>('');
  const [selectedDept, setSelectedDept] = useState<string>('');
  const [selectedShiftForAssign, setSelectedShiftForAssign] = useState<string>('');
  const [roster, setRoster] = useState<RosterState>(new Map());
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [savingProgress, setSavingProgress] = useState<number | null>(null);
  const [activeTab, setActiveTab] = useState<'roster' | 'assigned'>('roster');
  const [holidays, setHolidays] = useState<Holiday[]>([]);
  const [holidayGroups, setHolidayGroups] = useState<HolidayGroup[]>([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [page, setPage] = useState(1);
  const [limit, setLimit] = useState(ROSTER_LIMIT);
  const [totalPages, setTotalPages] = useState(1);
  const [totalEmployees, setTotalEmployees] = useState(0);

  const [showWeekOff, setShowWeekOff] = useState(false);
  const weekdays = useMemo(() => ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], []);
  const [weekOffDays, setWeekOffDays] = useState<Record<string, boolean>>(
    weekdays.reduce((acc, w) => ({ ...acc, [w]: false }), {})
  );
  const [shiftAssignDays, setShiftAssignDays] = useState<Record<string, boolean>>(
    weekdays.reduce((acc, w) => ({ ...acc, [w]: false }), {})
  );

  const days = useMemo(() => getMonthDays(month), [month]);

  // Debounced search to prevent UI lag
  const [debouncedSearch, setDebouncedSearch] = useState('');
  useEffect(() => {
    const timer = setTimeout(() => setDebouncedSearch(searchTerm), 300);
    return () => clearTimeout(timer);
  }, [searchTerm]);

  const globalHolidayDates = useMemo(() => {
    const dates = new Set<string>();
    holidays.forEach(h => {
      const start = h.date ? format(parseISO(h.date), 'yyyy-MM-dd') : '';
      const end = h.endDate ? format(parseISO(h.endDate), 'yyyy-MM-dd') : start;
      if (!start) return;
      days.forEach(d => {
        if (d >= start && d <= end) dates.add(d);
      });
    });
    return dates;
  }, [holidays, days]);

  const holidayCache = useMemo(() => {
    const cache = new Map<string, Set<string>>();
    if (!employees || !holidays || holidays.length === 0 || days.length === 0) return cache;
    const monthStart = days[0];
    const monthEnd = days[days.length - 1];
    const monthHolidays = holidays.filter(h => {
      const start = h.date ? format(parseISO(h.date), 'yyyy-MM-dd') : '';
      const end = h.endDate ? format(parseISO(h.endDate), 'yyyy-MM-dd') : start;
      return (start && start <= monthEnd) && (end && end >= monthStart);
    });
    if (monthHolidays.length === 0) return cache;
    employees.forEach(emp => {
      const empHolidays = new Set<string>();
      monthHolidays.forEach(h => {
        const start = h.date ? format(parseISO(h.date), 'yyyy-MM-dd') : '';
        const end = h.endDate ? format(parseISO(h.endDate), 'yyyy-MM-dd') : start;
        let isApplicable = false;
        if (h.scope === 'GLOBAL') {
          if (h.applicableTo === 'ALL') {
            const override = monthHolidays.find(o =>
              o.overridesMasterId === h._id && o.scope === 'GROUP' && checkGroupApplicability(o, emp, holidayGroups)
            );
            isApplicable = !override;
          } else if (h.applicableTo === 'SPECIFIC_GROUPS') {
            isApplicable = checkGroupApplicability(h, emp, holidayGroups);
          } else isApplicable = true;
        } else if (h.scope === 'GROUP') isApplicable = checkGroupApplicability(h, emp, holidayGroups);
        if (isApplicable) days.forEach(d => { if (d >= start && d <= end) empHolidays.add(d); });
      });
      cache.set(emp.emp_no, empHolidays);
    });
    return cache;
  }, [employees, holidays, holidayGroups, days]);

  const loadData = useCallback(async () => {
    setLoading(true);
    try {
      const [shiftRes, divRes, deptRes, holidayRes] = await Promise.all([
        api.getShifts(),
        api.getDivisions(),
        api.getDepartments(),
        api.getAllHolidaysAdmin(parseInt(month.split('-')[0]))
      ]);
      setShifts(shiftRes.data || []);
      setDivisions(divRes.data || []);
      setDepartments(deptRes.data || []);
      if (holidayRes && holidayRes.data) {
        if (Array.isArray(holidayRes.data)) setHolidays(holidayRes.data);
        else {
          setHolidays(holidayRes.data.holidays || []);
          setHolidayGroups(holidayRes.data.groups || []);
        }
      }
      const empParams: any = { page, limit };
      if (selectedDept) empParams.department_id = selectedDept;
      if (selectedDivision) empParams.division_id = selectedDivision;
      const empRes = await api.getEmployees(empParams) as any;
      const empList = empRes.data || [];
      setEmployees(empList);
      setTotalPages(empRes.pagination?.totalPages || 1);
      setTotalEmployees(empRes.pagination?.total || empList.length);
      const rosterRes = await api.getRoster(month, {
        departmentId: selectedDept || undefined,
        divisionId: selectedDivision || undefined
      });
      const entries = rosterRes.data?.entries || [];
      const map = new Map<string, Record<string, RosterCell>>();
      entries.forEach((e: any) => {
        if (!e.employeeNumber) return;
        if (!map.has(e.employeeNumber)) map.set(e.employeeNumber, {});
        map.get(e.employeeNumber)![e.date] = {
          shiftId: e.shiftId || null,
          status: e.status === 'WO' ? 'WO' : (e.status === 'HOL' ? 'HOL' : undefined)
        };
      });
      setRoster(map);
    } catch (err) {
      console.error('Error loading roster data:', err);
      toast.error('Failed to load roster');
    } finally { setLoading(false); }
  }, [month, selectedDept, selectedDivision, page, limit]);

  useEffect(() => { loadData(); }, [loadData]);

  const updateCell = useCallback((empNo: string, date: string, value: RosterCell) => {
    setRoster(prev => {
      const next = new Map(prev);
      const row = { ...(next.get(empNo) || {}) };
      row[date] = value;
      next.set(empNo, row);
      return next;
    });
  }, []);

  const applyEmployeeAllDays = useCallback((empNo: string, shiftId: string | null, status?: 'WO' | 'HOL') => {
    setRoster(prev => {
      const next = new Map(prev);
      const row = { ...(next.get(empNo) || {}) };
      days.forEach(d => {
        // Only skip if we are assigning a shift (shiftId provided) AND current status is protected
        if (shiftId && (row[d]?.status === 'WO' || row[d]?.status === 'HOL')) return;
        row[d] = { shiftId, status };
      });
      next.set(empNo, row);
      return next;
    });
  }, [days]);

  const applyAssignDays = useCallback((shiftId: string | null, status?: 'WO' | 'HOL') => {
    const activeDays = Object.keys(shiftAssignDays).filter(d => shiftAssignDays[d]);
    if (activeDays.length === 0) return;
    setRoster(prev => {
      const next = new Map(prev);
      employees.forEach(emp => {
        const row = { ...(next.get(emp.emp_no) || {}) };
        days.forEach(d => {
          const date = new Date(d);
          if (activeDays.includes(weekdays[date.getDay()])) {
            // Only skip if we are assigning a shift (shiftId provided) AND current status is protected
            if (shiftId && (row[d]?.status === 'WO' || row[d]?.status === 'HOL')) return;
            row[d] = { shiftId, status };
          }
        });
        next.set(emp.emp_no, row);
      });
      return next;
    });
  }, [days, shiftAssignDays, weekdays, employees]);

  const handleAssignAll = useCallback(() => {
    if (!selectedShiftForAssign) return;
    applyAssignDays(selectedShiftForAssign);
    toast.success('Assigned shift to all employees on selected weekdays');
  }, [selectedShiftForAssign, applyAssignDays]);

  const applyWeekOffs = useCallback(() => {
    const activeDays = Object.keys(weekOffDays).filter(d => weekOffDays[d]);
    if (activeDays.length === 0) return;
    setRoster(prev => {
      const next = new Map(prev);
      employees.forEach(emp => {
        const row = { ...(next.get(emp.emp_no) || {}) };
        days.forEach(d => {
          const date = new Date(d);
          if (activeDays.includes(weekdays[date.getDay()])) row[d] = { shiftId: null, status: 'WO' };
        });
        next.set(emp.emp_no, row);
      });
      return next;
    });
    setShowWeekOff(false);
    toast.success('Assigned week offs');
  }, [days, weekOffDays, weekdays, employees]);

  const saveRoster = async () => {
    setSaving(true);
    setSavingProgress(0);
    try {
      const entries: any[] = [];
      roster.forEach((row, empNo) => {
        Object.entries(row).forEach(([date, cell]) => {
          if (cell.shiftId || cell.status) {
            entries.push({
              employeeNumber: empNo,
              date,
              shiftId: cell.shiftId || null,
              status: cell.status || 'SHIFT'
            });
          }
        });
      });
      const batchSize = 100;
      for (let i = 0; i < entries.length; i += batchSize) {
        const batch = entries.slice(i, i + batchSize);
        await api.saveRoster({ month, entries: batch, strict });
        setSavingProgress(Math.round(((i + batchSize) / entries.length) * 100));
      }
      toast.success('Roster saved successfully');
    } catch (err) {
      console.error('Error saving roster:', err);
      toast.error('Failed to save roster');
    } finally {
      setSaving(false);
      setSavingProgress(null);
    }
  };

  const assignedShiftsSummary = useMemo(() => {
    if (activeTab !== 'assigned') return [];
    const summary: AssignmentSummaryItem[] = [];
    employees.forEach(emp => {
      const row = roster.get(emp.emp_no) || {};
      const shiftMap = new Map<string | null, { label: string; dates: string[] }>();
      Object.entries(row).forEach(([date, cell]) => {
        const isWO = cell?.status === 'WO', isHOL = cell?.status === 'HOL';
        const shiftId = isWO ? 'WO' : (isHOL ? 'HOL' : (cell?.shiftId || null));
        const label = isWO ? 'Week Off' : (isHOL ? 'Holiday' : (shiftId ? shiftLabel(shifts.find(s => s._id === shiftId)) : 'Unassigned'));
        const key = isWO ? 'WO' : (isHOL ? 'HOL' : shiftId);
        if (!shiftMap.has(key)) shiftMap.set(key, { label, dates: [] });
        shiftMap.get(key)!.dates.push(date);
      });
      if (shiftMap.size > 0) {
        const shiftsList = Array.from(shiftMap.entries()).map(([sid, data]) => ({
          shiftId: sid, shiftLabel: data.label, days: data.dates.length, dates: data.dates.sort()
        })).sort((a, b) => (a.shiftId === 'WO' ? -1 : b.shiftId === 'WO' ? 1 : (a.shiftId === 'HOL' ? -1 : b.shiftId === 'HOL' ? 1 : 0)));
        summary.push({
          employee: emp, shifts: shiftsList,
          totalDays: shiftsList.reduce((s, x) => s + x.days, 0),
          weekOffs: shiftsList.find(s => s.shiftId === 'WO')?.days || 0,
          holidays: shiftsList.find(s => s.shiftId === 'HOL')?.days || 0
        });
      }
    });
    return summary.sort((a, b) => (a.employee.employee_name || a.employee.emp_no).localeCompare(b.employee.employee_name || b.employee.emp_no));
  }, [employees, roster, shifts, activeTab]);

  const filteredAssignedSummary = useMemo(() => {
    if (activeTab !== 'assigned' || !assignedShiftsSummary) return [];
    if (!debouncedSearch) return assignedShiftsSummary;
    const term = debouncedSearch.toLowerCase();
    return assignedShiftsSummary.filter(it =>
      (it.employee.employee_name || '').toLowerCase().includes(term) || (it.employee.emp_no || '').toLowerCase().includes(term)
    );
  }, [assignedShiftsSummary, debouncedSearch, activeTab]);

  const handleExportExcel = async () => {
    const exportToast = toast.loading('Preparing export...');
    try {
      const divisionName = selectedDivision ? (divisions.find(d => d._id === selectedDivision)?.name || 'Division') : 'All';
      const deptName = selectedDept ? (departments.find(d => d._id === selectedDept)?.name || 'Dept') : 'All';
      const [allEmpsRes, allRosterRes] = await Promise.all([
        api.getEmployees({ limit: 10000, department_id: selectedDept || undefined, division_id: selectedDivision || undefined }),
        api.getRoster(month, { departmentId: selectedDept || undefined, divisionId: selectedDivision || undefined })
      ]);
      const allEmps = allEmpsRes.data || [], allEntries = allRosterRes.data?.entries || [];
      const fullMap = new Map<string, any>();
      allEntries.forEach((e: any) => {
        if (!e.employeeNumber) return;
        if (!fullMap.has(e.employeeNumber)) fullMap.set(e.employeeNumber, {});
        fullMap.get(e.employeeNumber)![e.date] = { shiftId: e.shiftId || null, status: e.status };
      });
      const data: any[][] = [[`Shift Roster - ${divisionName} / ${deptName} - ${month}`], [], ['Emp No', 'Name', 'Division', 'Dept', ...days.map(d => format(parseISO(d), 'dd-MMM'))]];
      allEmps.forEach((emp: any) => {
        const row = [emp.emp_no, emp.employee_name || '-', emp.division?.name || '-', emp.department?.name || '-'];
        days.forEach(d => {
          const cell = (fullMap.get(emp.emp_no) || {})[d];
          if (cell?.status === 'WO') row.push('WO');
          else if (cell?.status === 'HOL') row.push('HOL');
          else if (cell?.shiftId) row.push(shiftLabel(shifts.find(s => s._id === cell.shiftId)));
          else row.push('-');
        });
        data.push(row);
      });
      const ws = XLSX.utils.aoa_to_sheet(data);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Roster');
      XLSX.writeFile(wb, `Shift_Roster_${month}.xlsx`);
      toast.success('Roster exported');
    } catch (err) { console.error('Export error:', err); toast.error('Export failed'); } finally { toast.dismiss(exportToast); }
  };

  const filteredEmployees = useMemo(() => {
    if (!debouncedSearch) return employees;
    const term = debouncedSearch.toLowerCase();
    return employees.filter(emp => (emp.employee_name || '').toLowerCase().includes(term) || (emp.emp_no || '').toLowerCase().includes(term));
  }, [employees, debouncedSearch]);

  return (
    <div className="relative min-h-screen bg-[#f8fafc] dark:bg-[#020617]">
      <div className="pointer-events-none fixed inset-0 bg-[linear-gradient(to_right,#e2e8f01f_1px,transparent_1px),linear-gradient(to_bottom,#e2e8f01f_1px,transparent_1px)] bg-[size:28px_28px] dark:bg-[linear-gradient(to_right,rgba(148,163,184,0.08)_1px,transparent_1px),linear-gradient(to_bottom,rgba(148,163,184,0.08)_1px,transparent_1px)]" />
      <div className="pointer-events-none fixed inset-0 bg-gradient-to-br from-blue-50/20 via-indigo-50/20 to-transparent dark:from-slate-900/40 dark:via-slate-900/40 dark:to-slate-900/60" />

      <div className="relative z-10 w-auto -mt-4 sm:-mt-5 lg:-mt-6 -mx-4 sm:-mx-5 lg:-mx-6 pb-6 space-y-0.5">
        <div className="flex flex-col lg:flex-row lg:items-center justify-between gap-4 border-b border-slate-200/60 bg-white/80 p-4 shadow-[0_2px_15px_rgba(0,0,0,0.02)] backdrop-blur-md dark:border-slate-800/60 dark:bg-slate-950/80 sm:px-6">
          <div className="flex items-center gap-3">
            <div className="p-1.5 rounded-lg bg-blue-500/10 text-blue-600 dark:bg-blue-500/20 dark:text-blue-400"><LayoutGrid size={18} /></div>
            <h1 className="text-lg font-black tracking-tight text-slate-900 dark:text-slate-50 uppercase">Shift Roster</h1>
          </div>
          <div className="flex flex-wrap items-center gap-4 lg:justify-end">
            <div className="flex flex-wrap items-center gap-y-2 gap-x-4">
              <div className="flex items-center gap-1.5 py-1 px-2.5 rounded-lg bg-orange-50/50 dark:bg-orange-950/20 border border-orange-100 dark:border-orange-900/40">
                <span className="h-2 w-2 rounded-full bg-orange-400"></span><span className="text-[9px] font-black uppercase text-orange-700 dark:text-orange-400">Week Off</span>
              </div>
              <div className="flex items-center gap-1.5 py-1 px-2.5 rounded-lg bg-red-50/50 dark:bg-red-950/20 border border-red-100 dark:border-red-900/40">
                <span className="h-2 w-2 rounded-full bg-red-400"></span><span className="text-[9px] font-black uppercase text-red-700 dark:text-red-400">Holiday</span>
              </div>
              {shifts.slice(0, 6).map(s => (
                <div key={s._id} className="flex items-center gap-1.5 py-1 px-2.5 rounded-lg bg-white dark:bg-slate-900 border border-slate-200/60 dark:border-slate-800/60">
                  <span className="h-2 w-2 rounded-full" style={{ backgroundColor: s.color || '#3b82f6' }}></span>
                  <span className="text-[9px] font-black uppercase text-slate-600 dark:text-slate-400">{shiftLabel(s)}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        <div className="flex flex-col xl:flex-row xl:items-center justify-between gap-4 sm:px-6 py-2 bg-white/40 dark:bg-slate-950/20 border-b border-slate-200/40 dark:border-slate-800/40">
          <RosterFilters
            selectedDivision={selectedDivision} setSelectedDivision={setSelectedDivision} divisions={divisions}
            selectedDept={selectedDept} setSelectedDept={setSelectedDept} departments={departments}
            month={month} setMonth={setMonth} setPage={setPage}
          />
          <SearchSection onSearchChange={setSearchTerm} />
          <div className="flex items-center gap-3">
            <button onClick={handleExportExcel} className="flex items-center gap-2 px-5 py-2.5 rounded-xl bg-green-600 border border-green-700 text-white text-[10px] font-black uppercase tracking-widest hover:bg-green-700 transition-all shadow-md"><Download size={14} />Export</button>
            <button onClick={() => setShowWeekOff(true)} className="flex items-center gap-2 px-5 py-2.5 rounded-xl bg-slate-900 border border-slate-800 text-white text-[10px] font-black uppercase tracking-widest transition-all shadow-md dark:bg-slate-800/80"><Settings2 size={14} />Assign Offs</button>
            <button onClick={saveRoster} disabled={saving} className="flex items-center gap-2 px-6 py-2.5 rounded-xl bg-gradient-to-br from-blue-600 to-indigo-700 text-white text-[11px] font-black uppercase tracking-widest shadow-lg shadow-blue-500/20 disabled:opacity-50 transition-all"><Save size={16} />{saving ? `...${savingProgress}%` : 'Save Roster'}</button>
          </div>
        </div>

        <div className="flex flex-col lg:flex-row lg:items-center justify-between gap-4 bg-white/40 dark:bg-slate-950/20 border-b border-slate-200/40 dark:border-slate-800/40 sm:px-6 py-2">
          <div className="flex items-center gap-4">
            <div className="flex gap-1.5 p-1 rounded-xl bg-indigo-50/20 dark:bg-slate-900/30 border border-slate-200/60 dark:border-slate-800/60 backdrop-blur-sm">
              <button onClick={() => setActiveTab('roster')} className={`flex items-center gap-2 px-6 py-2 rounded-xl text-[10px] font-black uppercase transition-all ${activeTab === 'roster' ? 'bg-white text-indigo-600 shadow-sm dark:bg-slate-900 dark:text-blue-400' : 'text-slate-500'}`}><LayoutGrid size={12} />Grid View</button>
              <button onClick={() => setActiveTab('assigned')} className={`flex items-center gap-2 px-6 py-2 rounded-xl text-[10px] font-black uppercase transition-all ${activeTab === 'assigned' ? 'bg-white text-indigo-600 shadow-sm dark:bg-slate-900 dark:text-blue-400' : 'text-slate-500'}`}><CheckCircle2 size={12} />Assignments</button>
            </div>
            {/* Strict Mode Toggle Hidden for now */}
            {/* <label className="flex items-center gap-1.5 px-3 py-2 rounded-xl cursor-pointer hover:bg-slate-100 dark:hover:bg-slate-800 border bg-white dark:bg-slate-900 shadow-sm">
              <input type="checkbox" checked={strict} onChange={e => setStrict(e.target.checked)} className="sr-only peer" />
              <div className="w-8 h-4 bg-slate-200 rounded-full peer peer-checked:bg-blue-600 after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-3 after:w-3 after:transition-all peer-checked:after:translate-x-full"></div>
              <span className="text-[10px] font-black uppercase text-slate-500">Strict mode</span>
            </label> */}
          </div>
          <QuickAssignSection
            weekdays={weekdays} shiftAssignDays={shiftAssignDays} setShiftAssignDays={setShiftAssignDays}
            selectedShiftForAssign={selectedShiftForAssign} setSelectedShiftForAssign={setSelectedShiftForAssign}
            shifts={shifts} handleAssignAll={handleAssignAll} shiftLabel={shiftLabel}
          />
        </div>

        <div className="p-0 sm:p-2 lg:p-4">
          {activeTab === 'roster' ? (
            <RosterGrid
              loading={loading} filteredEmployees={filteredEmployees} totalEmployees={totalEmployees}
              page={page} setPage={setPage} totalPages={totalPages}
              limit={limit} setLimit={setLimit}
              days={days} weekdays={weekdays}
              roster={roster} holidayCache={holidayCache} shifts={shifts} updateCell={updateCell}
              applyEmployeeAllDays={applyEmployeeAllDays} globalHolidayDates={globalHolidayDates} shiftLabel={shiftLabel}
            />
          ) : (
            <AssignmentsView
              filteredAssignedSummary={filteredAssignedSummary} shifts={shifts} shiftLabel={shiftLabel}
            />
          )}
        </div>

        <WeekOffModal
          showWeekOff={showWeekOff} setShowWeekOff={setShowWeekOff} weekOffDays={weekOffDays}
          setWeekOffDays={setWeekOffDays} applyWeekOffs={applyWeekOffs} weekdays={weekdays}
        />
      </div>
    </div>
  );
}
