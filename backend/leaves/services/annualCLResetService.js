/**
 * Annual CL Reset Service
 * Handles annual casual leave balance rollover and carry forward expiration
 */

const Employee = require('../../employees/model/Employee');
const LeavePolicySettings = require('../../settings/model/LeavePolicySettings');
const leaveRegisterService = require('./leaveRegisterService');
const { extractISTComponents, createISTDate } = require('../../shared/utils/dateUtils');
const dateCycleService = require('./dateCycleService');

/**
 * Perform annual CL rollover for all active employees
 * @param {Number} targetYear - Target year for reset (optional, defaults to current financial year)
 * @returns {Object} Reset operation results
 */
async function performAnnualCLReset(targetYear = null) {
    try {
        console.log('[AnnualCLReset] Starting Annual CL Rollover process...');

        const settings = await LeavePolicySettings.getSettings();

        if (!settings.annualCLReset.enabled) {
            return {
                success: false,
                message: 'Annual CL reset is disabled in settings',
                processed: 0,
                errors: []
            };
        }

        const resetDate = getResetDate(targetYear, settings);
        console.log(`[AnnualCLReset] Rollover execution date: ${resetDate.toISOString()}`);

        const employees = await Employee.find({ is_active: true })
            .select('_id emp_no employee_name department_id division_id doj is_active paidLeaves')
            .populate('department_id', 'name')
            .populate('division_id', 'name');

        const results = {
            success: true,
            resetDate,
            processed: 0,
            successCount: 0,
            errors: [],
            details: []
        };

        for (const employee of employees) {
            try {
                const resetResult = await resetEmployeeCL(employee, settings, resetDate);

                if (resetResult.success) {
                    results.successCount++;
                    results.details.push({
                        employeeId: employee._id,
                        empNo: employee.emp_no,
                        previousBalance: resetResult.previousBalance,
                        expiredAmount: resetResult.expiredAmount,
                        carryForwarded: resetResult.carryForwarded
                    });
                } else {
                    results.errors.push({ empNo: employee.emp_no, error: resetResult.error });
                }

                results.processed++;
            } catch (error) {
                results.errors.push({ empNo: employee.emp_no, error: error.message });
            }
        }

        return {
            ...results,
            message: `Annual CL Rollover completed: ${results.successCount} successful, ${results.errors.length} errors`
        };

    } catch (error) {
        console.error('[AnnualCLReset] Critical error:', error);
        return { success: false, error: error.message, message: 'Annual CL Rollover failed' };
    }
}

/**
 * Handle carry forward and expiration for a single employee
 */
async function resetEmployeeCL(employee, settings, resetDate) {
    try {
        // 1. Get exact current balance from ledger
        const currentBalance = await leaveRegisterService.getCurrentBalance(employee._id, 'CL');

        let carryForwardAllowed = 0;
        let expiredAmount = 0;

        // 2. Calculate Carry Forward bounds
        if (settings.carryForward.casualLeave.enabled) {
            // maxMonths is historically used as maxDays limit for CF in this schema
            const maxCF = settings.carryForward.casualLeave.maxMonths || 12;
            carryForwardAllowed = Math.min(currentBalance, maxCF);
        }

        expiredAmount = Math.max(0, currentBalance - carryForwardAllowed);

        // 3. Post EXPIRY transaction if balance exceeds CF limits
        if (expiredAmount > 0) {
            await leaveRegisterService.addTransaction({
                employeeId: employee._id,
                empNo: employee.emp_no,
                employeeName: employee.employee_name,
                designation: 'N/A', // Omitted for brevity
                department: employee.department_id?.name || 'N/A',
                divisionId: employee.division_id?._id,
                departmentId: employee.department_id?._id,
                dateOfJoining: employee.doj,
                employmentStatus: employee.is_active ? 'active' : 'inactive',
                leaveType: 'CL',
                transactionType: 'EXPIRY',
                startDate: resetDate,
                endDate: resetDate,
                days: expiredAmount,
                reason: `Annual Financial Year Reset: Unused CL exceeds Carry Forward limits. Expired ${expiredAmount} days.`,
                status: 'APPROVED',
                autoGenerated: true,
                autoGeneratedType: 'EXPIRY'
            });
        }

        return {
            success: true,
            previousBalance: currentBalance,
            carryForwarded: carryForwardAllowed,
            expiredAmount: expiredAmount
        };

    } catch (error) {
        return { success: false, error: error.message };
    }
}

/**
 * Get reset date based on settings
 */
function getResetDate(targetYear, settings) {
    if (targetYear) {
        return createISTDate(`${targetYear}-${String(settings.annualCLReset.resetMonth).padStart(2, '0')}-${String(settings.annualCLReset.resetDay).padStart(2, '0')}`);
    }

    // Default to current financial year start
    const now = new Date();
    const currentYear = now.getMonth() + 1 >= settings.annualCLReset.resetMonth ?
        now.getFullYear() : now.getFullYear() - 1;

    return createISTDate(`${currentYear}-${String(settings.annualCLReset.resetMonth).padStart(2, '0')}-${String(settings.annualCLReset.resetDay).padStart(2, '0')}`);
}

/**
 * Get CL reset status for employees
 */
async function getCLResetStatus(employeeIds = null) {
    try {
        const query = { is_active: true };
        if (employeeIds && employeeIds.length > 0) {
            query._id = { $in: employeeIds };
        }

        const employees = await Employee.find(query)
            .select('_id emp_no employee_name paidLeaves department_id division_id')
            .populate('department_id', 'name')
            .populate('division_id', 'name')
            .lean();

        const settings = await LeavePolicySettings.getSettings();

        const results = employees.map(emp => ({
            employeeId: emp._id,
            empNo: emp.emp_no,
            employeeName: emp.employee_name,
            department: emp.department_id?.name,
            division: emp.division_id?.name,
            currentCL: emp.paidLeaves || 0,
            nextResetDate: getNextResetDate(settings),
            rolloverEnabled: settings.annualCLReset.enabled,
            carryForwardEnabled: settings.carryForward.casualLeave.enabled,
            carryForwardMax: settings.carryForward.casualLeave.maxMonths || 12
        }));

        return {
            success: true,
            data: results,
            settings: {
                enabled: settings.annualCLReset.enabled,
                resetMonth: settings.annualCLReset.resetMonth,
                resetDay: settings.annualCLReset.resetDay,
                carryForwardEnabled: settings.carryForward.casualLeave.enabled,
                carryForwardMax: settings.carryForward.casualLeave.maxMonths || 12
            }
        };

    } catch (error) {
        console.error('Error getting CL reset status:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Get next reset date
 */
function getNextResetDate(settings) {
    const now = new Date();
    const currentYear = now.getMonth() + 1 >= settings.annualCLReset.resetMonth ?
        now.getFullYear() : now.getFullYear() - 1;

    return createISTDate(`${currentYear}-${String(settings.annualCLReset.resetMonth).padStart(2, '0')}-${String(settings.annualCLReset.resetDay).padStart(2, '0')}`);
}

module.exports = {
    performAnnualCLReset,
    getCLResetStatus,
    getNextResetDate
};
