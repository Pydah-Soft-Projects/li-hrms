const LeaveRegister = require('../model/LeaveRegister');
const Employee = require('../../employees/model/Employee');
const Leave = require('../model/Leave');
const dateCycleService = require('./dateCycleService');

/**
 * Leave Register Service
 * Manages complete ledger of all leave transactions with audit transparency
 */

class LeaveRegisterService {
    /**
     * Add leave transaction to register
     */
    async addTransaction(transactionData) {
        try {
            // Get period info for the transaction date
            const periodInfo = await dateCycleService.getPeriodInfo(transactionData.startDate);

            // Get previous balance for this employee and leave type
            const previousEntry = await LeaveRegister.getEmployeeBalance(
                transactionData.employeeId,
                transactionData.leaveType,
                transactionData.startDate
            );

            const openingBalance = previousEntry ? previousEntry.closingBalance : 0;

            // Create new transaction with proper period info
            const transaction = new LeaveRegister({
                ...transactionData,
                openingBalance,
                closingBalance: this.calculateClosingBalance(openingBalance, transactionData),
                // Use payroll cycle month/year instead of calendar
                month: periodInfo.payrollCycle.month,
                year: periodInfo.payrollCycle.year,
                financialYear: periodInfo.financialYear.name,
                // Store period details for reference
                payrollCycleStart: periodInfo.payrollCycle.startDate,
                payrollCycleEnd: periodInfo.payrollCycle.endDate,
                financialYearStart: periodInfo.financialYear.startDate,
                financialYearEnd: periodInfo.financialYear.endDate
            });

            const savedTransaction = await transaction.save();

            // Update employee leave balance in employee model
            await this.updateEmployeeBalance(transactionData.employeeId, transactionData.leaveType);

            return savedTransaction;
        } catch (error) {
            console.error('Error adding leave transaction:', error);
            throw error;
        }
    }

    /**
     * Add earned leave credit (auto-generated)
     */
    async addEarnedLeaveCredit(employeeId, elEarned, month, year, calculationBreakdown = null) {
        try {
            const employee = await Employee.findById(employeeId);
            if (!employee) {
                throw new Error('Employee not found');
            }

            // Get payroll cycle info for the given month/year
            const cycleDate = new Date(year, month - 1, 15); // Middle of month to get correct cycle
            const periodInfo = await dateCycleService.getPeriodInfo(cycleDate);

            const transactionData = {
                employeeId,
                empNo: employee.emp_no,
                employeeName: employee.name,
                designation: employee.designation || 'N/A',
                department: employee.department || 'N/A',
                divisionId: employee.division_id,
                departmentId: employee.department_id,
                dateOfJoining: employee.date_of_joining,
                employmentStatus: employee.is_active ? 'active' : 'inactive',

                leaveType: 'EL',
                transactionType: 'CREDIT',
                startDate: periodInfo.payrollCycle.startDate,
                endDate: periodInfo.payrollCycle.startDate,
                days: elEarned,
                reason: 'Earned Leave - Auto Credit',
                status: 'APPROVED',

                // Use payroll cycle period info
                month: periodInfo.payrollCycle.month,
                year: periodInfo.payrollCycle.year,
                financialYear: periodInfo.financialYear.name,
                autoGenerated: true,
                autoGeneratedType: 'EARNED_LEAVE',
                calculationBreakdown,

                // Store period details
                payrollCycleStart: periodInfo.payrollCycle.startDate,
                payrollCycleEnd: periodInfo.payrollCycle.endDate,
                financialYearStart: periodInfo.financialYear.startDate,
                financialYearEnd: periodInfo.financialYear.endDate
            };

            return await this.addTransaction(transactionData);
        } catch (error) {
            console.error('Error adding earned leave credit:', error);
            throw error;
        }
    }

    /**
     * Add leave debit (when leave is availed)
     */
    async addLeaveDebit(leaveRecord) {
        try {
            const employee = await Employee.findById(leaveRecord.employeeId)
                .populate('department_id', 'name')
                .populate('designation_id', 'name');
            if (!employee) {
                throw new Error('Employee not found');
            }

            const employeeName = employee.employee_name || employee.name;
            const designation = (employee.designation_id && employee.designation_id.name) || employee.designation?.name || 'N/A';
            const department = (employee.department_id && employee.department_id.name) || employee.department?.name || 'N/A';

            const transactionData = {
                employeeId: leaveRecord.employeeId,
                empNo: employee.emp_no,
                employeeName,
                designation,
                department,
                divisionId: employee.division_id,
                departmentId: employee.department_id,
                dateOfJoining: employee.doj || employee.date_of_joining,
                employmentStatus: employee.is_active ? 'active' : 'inactive',

                leaveType: leaveRecord.leaveType,
                transactionType: 'DEBIT',
                startDate: leaveRecord.fromDate,
                endDate: leaveRecord.toDate,
                days: leaveRecord.numberOfDays,
                applicationId: leaveRecord._id,
                applicationDate: leaveRecord.createdAt,
                approvalDate: leaveRecord.updatedAt, // Use updatedAt as approval date
                approvedBy: leaveRecord.workflow?.currentStepRole || 'system',
                status: leaveRecord.status,
                reason: leaveRecord.purpose
            };

            return await this.addTransaction(transactionData);
        } catch (error) {
            console.error('Error adding leave debit:', error);
            throw error;
        }
    }

    /**
     * Get leave register with filters
     */
    async getLeaveRegister(filters = {}, month = null, year = null) {
        try {
            const registerData = await LeaveRegister.getLeaveRegister(filters, month, year);

            // Populate employee details for all transactions
            const populatedData = await Promise.all(
                registerData.map(async (transaction) => {
                    if (transaction.employeeId && typeof transaction.employeeId === 'object') {
                        // If employeeId is already populated, use it
                        return transaction;
                    } else {
                        // Populate employee details
                        const employee = await Employee.findById(transaction.employeeId)
                            .select('employee_name emp_no designation_id department_id division_id doj is_active')
                            .populate('designation_id', 'name')
                            .populate('department_id', 'name')
                            .populate('division_id', 'name');

                        if (employee) {
                            transaction.employeeId = employee;
                            transaction.employeeName = employee.employee_name;
                            transaction.designation = employee.designation_id?.name || 'N/A';
                            transaction.department = employee.department_id?.name || 'N/A';
                            transaction.divisionName = employee.division_id?.name || 'N/A';
                            transaction.dateOfJoining = employee.doj;
                            transaction.employmentStatus = employee.is_active ? 'active' : 'inactive';
                        }
                    }
                    return transaction;
                })
            );

            // Group by employee and provide monthly breakdown
            let groupedData = this.groupByEmployeeMonthly(populatedData, month, year);

            // When balance-as-of was requested for one employee and register has no transactions, fallback to Employee.casualLeaves
            if (filters.balanceAsOf && (filters.employeeId || filters.empNo) && groupedData.length === 0) {
                const emp = filters.employeeId
                    ? await Employee.findById(filters.employeeId)
                        .select('_id emp_no employee_name designation_id department_id division_id doj is_active casualLeaves')
                        .populate('designation_id', 'name')
                        .populate('department_id', 'name')
                        .populate('division_id', 'name')
                        .lean()
                    : await Employee.findOne({ emp_no: filters.empNo })
                        .select('_id emp_no employee_name designation_id department_id division_id doj is_active casualLeaves')
                        .populate('designation_id', 'name')
                        .populate('department_id', 'name')
                        .populate('division_id', 'name')
                        .lean();
                if (emp) {
                    const clBalance = typeof emp.casualLeaves === 'number' ? emp.casualLeaves : 0;
                    groupedData = [{
                        employee: {
                            id: emp._id,
                            empNo: emp.emp_no,
                            name: emp.employee_name,
                            designation: emp.designation_id?.name || 'N/A',
                            department: emp.department_id?.name || 'N/A',
                            division: emp.division_id?.name || 'N/A',
                            doj: emp.doj,
                            status: emp.is_active ? 'active' : 'inactive'
                        },
                        casualLeave: { openingBalance: 0, accruedThisMonth: 0, earnedCCL: 0, usedThisMonth: 0, expired: 0, balance: clBalance, carryForward: 0 },
                        earnedLeave: { openingBalance: 0, accruedThisMonth: 0, usedThisMonth: 0, balance: 0 },
                        compensatoryOff: { openingBalance: 0, earned: 0, used: 0, expired: 0, balance: 0 },
                        totalPaidBalance: clBalance
                    }];
                }
            }

            // CL policy: 1 per month from first 12, plus any balance above 12. Enrich allowedRemaining when balanceAsOf.
            const reqYear = year ? Number(year) : new Date().getFullYear();
            const reqMonth = month ? Number(month) : new Date().getMonth() + 1;
            const ANNUAL_CL_CAP = 12;
            if (filters.balanceAsOf && groupedData.length > 0) {
                for (const entry of groupedData) {
                    if (!entry.casualLeave) continue;
                    const balance = Number(entry.casualLeave.balance) || 0;
                    const empId = entry.employee?.id || entry.employee?._id;
                    const empNo = entry.employee?.empNo;
                    const usedThisYear = await LeaveRegister.getCLUsedInYear(
                        empId ? { employeeId: empId } : { empNo },
                        reqYear
                    );
                    const fromFirst12 = Math.min(ANNUAL_CL_CAP, reqMonth);
                    const fromExtra = Math.max(0, balance - ANNUAL_CL_CAP);
                    const maxAllowableByNow = fromFirst12 + fromExtra;
                    const allowedRemaining = Math.max(0, maxAllowableByNow - usedThisYear);
                    entry.casualLeave.usedThisYear = usedThisYear;
                    entry.casualLeave.allowedRemaining = allowedRemaining;
                }
            }

            return groupedData;
        } catch (error) {
            console.error('Error getting leave register:', error);
            throw error;
        }
    }

    /**
     * Get employee leave ledger
     */
    async getEmployeeLedger(employeeId, leaveType, startDate, endDate) {
        try {
            const ledger = await LeaveRegister.getEmployeeLedger(employeeId, leaveType, startDate, endDate);

            return {
                employeeId,
                leaveType,
                startDate,
                endDate,
                transactions: ledger,
                openingBalance: ledger.length > 0 ? ledger[0].openingBalance : 0,
                closingBalance: ledger.length > 0 ? ledger[ledger.length - 1].closingBalance : 0,
                totalCredits: ledger.filter(t => t.transactionType === 'CREDIT').reduce((sum, t) => sum + t.days, 0),
                totalDebits: ledger.filter(t => t.transactionType === 'DEBIT').reduce((sum, t) => sum + t.days, 0)
            };
        } catch (error) {
            console.error('Error getting employee ledger:', error);
            throw error;
        }
    }

    /**
     * Get employee's complete leave register
     */
    async getEmployeeRegister(employeeId) {
        try {
            const employee = await Employee.findById(employeeId);
            if (!employee) {
                throw new Error('Employee not found');
            }

            // Get all leave transactions for this employee
            const allTransactions = await LeaveRegister.find({ employeeId })
                .sort({ createdAt: 1 });

            // Group by leave type
            const leaveTypes = {};

            allTransactions.forEach(transaction => {
                const leaveType = transaction.leaveType;

                if (!leaveTypes[leaveType]) {
                    leaveTypes[leaveType] = {
                        openingBalance: 0,
                        closingBalance: 0,
                        credits: 0,
                        debits: 0,
                        transactions: []
                    };
                }

                leaveTypes[leaveType].transactions.push(transaction);
                leaveTypes[leaveType].closingBalance = transaction.closingBalance;

                if (transaction.transactionType === 'CREDIT') {
                    leaveTypes[leaveType].credits += transaction.days;
                } else if (transaction.transactionType === 'DEBIT') {
                    leaveTypes[leaveType].debits += transaction.days;
                }

                // Set opening balance from first transaction
                if (leaveTypes[leaveType].transactions.length === 1) {
                    leaveTypes[leaveType].openingBalance = transaction.openingBalance;
                }
            });

            return {
                employeeId: employee._id,
                empNo: employee.emp_no,
                employeeName: employee.name,
                designation: employee.designation || 'N/A',
                department: employee.department || 'N/A',
                divisionName: 'N/A', // TODO: Populate from division
                dateOfJoining: employee.date_of_joining,
                employmentStatus: employee.is_active ? 'active' : 'inactive',
                leaveTypes
            };
        } catch (error) {
            console.error('Error getting employee register:', error);
            throw error;
        }
    }

    /**
     * Get current balance for employee
     */
    async getCurrentBalance(employeeId, leaveType, asOfDate = new Date()) {
        try {
            const balance = await LeaveRegister.getEmployeeBalance(employeeId, leaveType, asOfDate);
            return balance ? balance.closingBalance : 0;
        } catch (error) {
            console.error('Error getting current balance:', error);
            throw error;
        }
    }

    /**
     * Helper methods
     */
    calculateClosingBalance(openingBalance, transactionData) {
        const { transactionType, days } = transactionData;

        if (transactionType === 'CREDIT') {
            return openingBalance + days;
        } else if (transactionType === 'DEBIT' || transactionType === 'EXPIRY') {
            return Math.max(0, openingBalance - days);
        } else if (transactionType === 'ADJUSTMENT') {
            return days; // For adjustments, set directly
        }
        return openingBalance;
    }

    /**
     * Group transactions by employee with monthly summary breakdown
     */
    groupByEmployeeMonthly(transactions, month, year) {
        const grouped = {};

        transactions.forEach(transaction => {
            const employeeId = transaction.employeeId._id || transaction.employeeId.id || transaction.employeeId;
            const key = employeeId.toString();

            if (!grouped[key]) {
                const emp = transaction.employeeId;
                grouped[key] = {
                    employee: {
                        id: employeeId,
                        empNo: transaction.empNo,
                        name: transaction.employeeName,
                        designation: transaction.designation,
                        department: transaction.department,
                        division: transaction.divisionName,
                        doj: transaction.dateOfJoining,
                        status: transaction.employmentStatus
                    },
                    casualLeave: { openingBalance: 0, accruedThisMonth: 0, earnedCCL: 0, usedThisMonth: 0, expired: 0, balance: 0, carryForward: 0 },
                    earnedLeave: { openingBalance: 0, accruedThisMonth: 0, usedThisMonth: 0, balance: 0 },
                    compensatoryOff: { openingBalance: 0, earned: 0, used: 0, expired: 0, balance: 0 },
                    totalPaidBalance: 0
                };
            }

            const leaveType = transaction.leaveType;
            const type = transaction.transactionType;
            const days = transaction.days;

            if (leaveType === 'CL') {
                const cl = grouped[key].casualLeave;
                if (cl.openingBalance === 0) cl.openingBalance = transaction.openingBalance;
                cl.balance = transaction.closingBalance;

                if (type === 'CREDIT') {
                    if (transaction.autoGeneratedType === 'INITIAL_BALANCE') cl.accruedThisMonth += days;
                    else if (transaction.reason?.includes('CCL')) cl.earnedCCL += days;
                    else cl.accruedThisMonth += days;
                } else if (type === 'DEBIT') {
                    cl.usedThisMonth += days;
                } else if (type === 'EXPIRY') {
                    cl.expired += days;
                } else if (type === 'CARRY_FORWARD') {
                    cl.carryForward += days;
                }
            } else if (leaveType === 'EL') {
                const el = grouped[key].earnedLeave;
                if (el.openingBalance === 0) el.openingBalance = transaction.openingBalance;
                el.balance = transaction.closingBalance;

                if (type === 'CREDIT') el.accruedThisMonth += days;
                else if (type === 'DEBIT') el.usedThisMonth += days;
            } else if (leaveType === 'CCL') {
                const ccl = grouped[key].compensatoryOff;
                if (ccl.openingBalance === 0) ccl.openingBalance = transaction.openingBalance;
                ccl.balance = transaction.closingBalance;

                if (type === 'CREDIT') ccl.earned += days;
                else if (type === 'DEBIT') ccl.used += days;
                else if (type === 'EXPIRY') ccl.expired += days;
            }
        });

        // Finalize balances and totals
        Object.values(grouped).forEach(entry => {
            entry.totalPaidBalance = entry.casualLeave.balance + entry.earnedLeave.balance + entry.compensatoryOff.balance;
        });

        return Object.values(grouped);
    }

    async updateEmployeeBalance(employeeId, leaveType) {
        try {
            const currentBalance = await this.getCurrentBalance(employeeId, leaveType);

            // Update employee model based on leave type
            const updateField = this.getEmployeeBalanceField(leaveType);
            await Employee.findByIdAndUpdate(employeeId, {
                [updateField]: currentBalance
            });
        } catch (error) {
            console.error('Error updating employee balance:', error);
            // Don't throw error here as it's not critical
        }
    }

    getEmployeeBalanceField(leaveType) {
        const fieldMap = {
            'EL': 'paidLeaves',
            'CL': 'casualLeaves',
            'SL': 'sickLeaves',
            'ML': 'maternityLeaves',
            'OD': 'onDutyLeaves',
            'CCL': 'compensatoryOffs'
        };
        return fieldMap[leaveType] || 'paidLeaves';
    }
}

module.exports = new LeaveRegisterService();
