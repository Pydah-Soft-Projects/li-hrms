const LeaveRegister = require('../model/LeaveRegister');
const Employee = require('../../employees/model/Employee');
const Leave = require('../model/Leave');
const dateCycleService = require('./dateCycleService');

/**
 * Leave Register Service
 * Manages complete ledger of all leave transactions with audit transparency
 */

class LeaveRegisterService {
    /**
     * Add leave transaction to register
     */
    async addTransaction(transactionData) {
        try {
            // Get period info for the transaction date
            const periodInfo = await dateCycleService.getPeriodInfo(transactionData.startDate);

            // Get previous balance for this employee and leave type
            const previousEntry = await LeaveRegister.getEmployeeBalance(
                transactionData.employeeId,
                transactionData.leaveType,
                transactionData.startDate
            );

            const openingBalance = previousEntry ? previousEntry.closingBalance : 0;

            // Create new transaction with proper period info
            const transaction = new LeaveRegister({
                ...transactionData,
                openingBalance,
                closingBalance: this.calculateClosingBalance(openingBalance, transactionData),
                // Use payroll cycle month/year instead of calendar
                month: periodInfo.payrollCycle.month,
                year: periodInfo.payrollCycle.year,
                financialYear: periodInfo.financialYear.name,
                // Store period details for reference
                payrollCycleStart: periodInfo.payrollCycle.startDate,
                payrollCycleEnd: periodInfo.payrollCycle.endDate,
                financialYearStart: periodInfo.financialYear.startDate,
                financialYearEnd: periodInfo.financialYear.endDate
            });

            const savedTransaction = await transaction.save();

            // Update employee leave balance in employee model
            await this.updateEmployeeBalance(transactionData.employeeId, transactionData.leaveType);

            return savedTransaction;
        } catch (error) {
            console.error('Error adding leave transaction:', error);
            throw error;
        }
    }

    /**
     * Add earned leave credit (auto-generated)
     */
    async addEarnedLeaveCredit(employeeId, elEarned, month, year, calculationBreakdown = null) {
        try {
            const employee = await Employee.findById(employeeId);
            if (!employee) {
                throw new Error('Employee not found');
            }

            // Get payroll cycle info for the given month/year
            const cycleDate = new Date(year, month - 1, 15); // Middle of month to get correct cycle
            const periodInfo = await dateCycleService.getPeriodInfo(cycleDate);

            const transactionData = {
                employeeId,
                empNo: employee.emp_no,
                employeeName: employee.name,
                designation: employee.designation || 'N/A',
                department: employee.department || 'N/A',
                divisionId: employee.division_id,
                departmentId: employee.department_id,
                dateOfJoining: employee.date_of_joining,
                employmentStatus: employee.is_active ? 'active' : 'inactive',

                leaveType: 'EL',
                transactionType: 'CREDIT',
                startDate: periodInfo.payrollCycle.startDate,
                endDate: periodInfo.payrollCycle.startDate,
                days: elEarned,
                reason: 'Earned Leave - Auto Credit',
                status: 'APPROVED',

                // Use payroll cycle period info
                month: periodInfo.payrollCycle.month,
                year: periodInfo.payrollCycle.year,
                financialYear: periodInfo.financialYear.name,
                autoGenerated: true,
                autoGeneratedType: 'EARNED_LEAVE',
                calculationBreakdown,

                // Store period details
                payrollCycleStart: periodInfo.payrollCycle.startDate,
                payrollCycleEnd: periodInfo.payrollCycle.endDate,
                financialYearStart: periodInfo.financialYear.startDate,
                financialYearEnd: periodInfo.financialYear.endDate
            };

            return await this.addTransaction(transactionData);
        } catch (error) {
            console.error('Error adding earned leave credit:', error);
            throw error;
        }
    }

    /**
     * Add leave debit (when leave is availed)
     */
    async addLeaveDebit(leaveRecord) {
        try {
            const employee = await Employee.findById(leaveRecord.employeeId)
                .populate('department_id', 'name')
                .populate('designation_id', 'name');
            if (!employee) {
                throw new Error('Employee not found');
            }

            const employeeName = employee.employee_name || 'N/A';
            const designation = (employee.designation_id && employee.designation_id.name) || employee.designation?.name || 'N/A';
            const department = (employee.department_id && employee.department_id.name) || employee.department?.name || 'N/A';

            const transactionData = {
                employeeId: leaveRecord.employeeId,
                empNo: employee.emp_no,
                employeeName,
                designation,
                department,
                divisionId: employee.division_id,
                departmentId: employee.department_id,
                dateOfJoining: employee.doj,
                employmentStatus: employee.is_active ? 'active' : 'inactive',

                leaveType: leaveRecord.leaveType,
                transactionType: 'DEBIT',
                startDate: leaveRecord.fromDate,
                endDate: leaveRecord.toDate,
                days: leaveRecord.numberOfDays,
                applicationId: leaveRecord._id,
                applicationDate: leaveRecord.createdAt,
                approvalDate: leaveRecord.updatedAt, // Use updatedAt as approval date
                approvedBy: leaveRecord.workflow?.currentStepRole || 'system',
                status: leaveRecord.status,
                reason: leaveRecord.purpose
            };

            return await this.addTransaction(transactionData);
        } catch (error) {
            console.error('Error adding leave debit:', error);
            throw error;
        }
    }

    /**
     * Add an ADJUSTMENT transaction for an employee's leave balance.
     * Used by admin/HR to correct CL/other leave balances via the register adjust API.
     */
    async addAdjustment(employeeId, leaveType, days, reason) {
        try {
            const employee = await Employee.findById(employeeId)
                .select('_id emp_no employee_name designation_id department_id division_id doj is_active')
                .populate('designation_id', 'name')
                .populate('department_id', 'name')
                .populate('division_id', 'name');
            if (!employee) {
                throw new Error('Employee not found');
            }

            const employeeName = employee.employee_name || 'N/A';
            const designation = (employee.designation_id && employee.designation_id.name) || employee.designation?.name || 'N/A';
            const department = (employee.department_id && employee.department_id.name) || employee.department?.name || 'N/A';

            const now = new Date();
            const transactionData = {
                employeeId: employee._id,
                empNo: employee.emp_no,
                employeeName,
                designation,
                department,
                divisionId: employee.division_id,
                departmentId: employee.department_id,
                dateOfJoining: employee.doj,
                employmentStatus: employee.is_active ? 'active' : 'inactive',

                leaveType,
                transactionType: 'ADJUSTMENT',
                startDate: now,
                endDate: now,
                days,
                reason,
                status: 'APPROVED',
                autoGenerated: false
            };

            return await this.addTransaction(transactionData);
        } catch (error) {
            console.error('Error adding adjustment transaction:', error);
            throw error;
        }
    }

    /**
     * Record EL used in payroll (when batch is completed).
     * Debits employee's EL balance and marks transaction as included in payroll.
     * @param {string} employeeId - Employee ID
     * @param {number} days - EL days used in payroll
     * @param {string} month - Payroll month YYYY-MM
     * @param {ObjectId} [payrollBatchId] - Optional batch reference
     */
    async addELUsedInPayroll(employeeId, days, month, payrollBatchId = null) {
        if (!employeeId || days == null || days <= 0) return null;
        const employee = await Employee.findById(employeeId)
            .select('_id emp_no employee_name designation_id department_id division_id doj is_active')
            .populate('designation_id', 'name')
            .populate('department_id', 'name')
            .populate('division_id', 'name')
            .lean();
        if (!employee) {
            throw new Error('Employee not found');
        }
        const [y, m] = month.split('-').map(Number);
        const cycleDate = new Date(y, m - 1, 15);
        const periodInfo = await dateCycleService.getPeriodInfo(cycleDate);
        const designation = (employee.designation_id && employee.designation_id.name) || 'N/A';
        const department = (employee.department_id && employee.department_id.name) || 'N/A';
        const transactionData = {
            employeeId: employee._id,
            empNo: employee.emp_no,
            employeeName: employee.employee_name || 'N/A',
            designation,
            department,
            divisionId: employee.division_id,
            departmentId: employee.department_id,
            dateOfJoining: employee.doj,
            employmentStatus: employee.is_active ? 'active' : 'inactive',
            leaveType: 'EL',
            transactionType: 'DEBIT',
            startDate: periodInfo.payrollCycle.startDate,
            endDate: periodInfo.payrollCycle.endDate,
            days: Number(days),
            reason: 'Included in payroll',
            status: 'APPROVED',
            autoGenerated: true,
            autoGeneratedType: 'PAYROLL_USE',
            includedInPayroll: true,
            payrollBatchId: payrollBatchId || undefined
        };
        return await this.addTransaction(transactionData);
    }

    /**
     * Get leave register with filters
     */
    async getLeaveRegister(filters = {}, month = null, year = null) {
        try {
            const registerData = await LeaveRegister.getLeaveRegister(filters, month, year);

            // Batch-fetch all employees so we always have designation/department/division (model populate only has name, email)
            const rawData = Array.isArray(registerData) ? registerData : [];
            const employeeIds = [...new Set(
                rawData
                    .map((t) => t.employeeId && (t.employeeId._id || t.employeeId))
                    .filter(Boolean)
            )];
            const employeesList = employeeIds.length > 0
                ? await Employee.find({ _id: { $in: employeeIds } })
                    .select('_id emp_no employee_name designation_id department_id division_id doj is_active')
                    .populate('designation_id', 'name')
                    .populate('department_id', 'name')
                    .populate('division_id', 'name')
                    .lean()
                : [];
            const empMap = new Map(employeesList.map((e) => [e._id.toString(), e]));

            const populatedData = rawData.map((transaction) => {
                const empId = transaction.employeeId && (transaction.employeeId._id || transaction.employeeId);
                if (!empId) return transaction;
                const emp = empMap.get(empId.toString());
                if (!emp) return transaction;
                const designation = (emp.designation_id && emp.designation_id.name) || 'N/A';
                const department = (emp.department_id && emp.department_id.name) || 'N/A';
                const divisionName = (emp.division_id && emp.division_id.name) || 'N/A';
                transaction.employeeName = emp.employee_name || 'N/A';
                transaction.designation = designation;
                transaction.department = department;
                transaction.divisionName = divisionName;
                transaction.dateOfJoining = emp.doj;
                transaction.employmentStatus = emp.is_active ? 'active' : 'inactive';
                transaction.employeeId = {
                    _id: emp._id,
                    id: emp._id,
                    empNo: emp.emp_no,
                    name: emp.employee_name,
                    designation,
                    department,
                    division: divisionName,
                    doj: emp.doj,
                    status: emp.is_active ? 'active' : 'inactive'
                };
                return transaction;
            });

            // Group by employee and provide monthly breakdown
            let groupedData = this.groupByEmployeeMonthly(populatedData, month, year);

            // When balance-as-of was requested for one employee and register has no transactions, fallback to Employee.casualLeaves
            if (filters.balanceAsOf && (filters.employeeId || filters.empNo) && groupedData.length === 0) {
                const emp = filters.employeeId
                    ? await Employee.findById(filters.employeeId)
                        .select('_id emp_no employee_name designation_id department_id division_id doj is_active casualLeaves paidLeaves compensatoryOffs')
                        .populate('designation_id', 'name')
                        .populate('department_id', 'name')
                        .populate('division_id', 'name')
                        .lean()
                    : await Employee.findOne({ emp_no: filters.empNo })
                        .select('_id emp_no employee_name designation_id department_id division_id doj is_active casualLeaves paidLeaves compensatoryOffs')
                        .populate('designation_id', 'name')
                        .populate('department_id', 'name')
                        .populate('division_id', 'name')
                        .lean();
                if (emp) {
                    const clBalance = typeof emp.casualLeaves === 'number' ? emp.casualLeaves : 0;
                    const elBalance = typeof emp.paidLeaves === 'number' ? emp.paidLeaves : 0;
                    const cclBalance = typeof emp.compensatoryOffs === 'number' ? emp.compensatoryOffs : 0;
                    const totalPaid = clBalance + elBalance + cclBalance;
                    groupedData = [{
                        employee: {
                            id: emp._id,
                            empNo: emp.emp_no,
                            name: emp.employee_name,
                            designation: emp.designation_id?.name || 'N/A',
                            department: emp.department_id?.name || 'N/A',
                            division: emp.division_id?.name || 'N/A',
                            doj: emp.doj,
                            status: emp.is_active ? 'active' : 'inactive'
                        },
                        casualLeave: { openingBalance: 0, accruedThisMonth: 0, earnedCCL: 0, usedThisMonth: 0, expired: 0, balance: clBalance, carryForward: 0 },
                        earnedLeave: { openingBalance: 0, accruedThisMonth: 0, usedThisMonth: 0, balance: elBalance },
                        compensatoryOff: { openingBalance: 0, earned: 0, used: 0, expired: 0, balance: cclBalance },
                        totalPaidBalance: totalPaid
                    }];
                }
            }

            // Monthly CL limit: protect at least 1 CL for each remaining month in the year.
            // Uses payroll cycle month index via dateCycleService.
            if (filters.balanceAsOf && groupedData.length > 0) {
                const dateCycleService = require('./dateCycleService');
                const today = new Date();
                const baseYear = year ? Number(year) : today.getFullYear();
                const baseMonth = month ? Number(month) : (today.getMonth() + 1);
                // Use the 15th of the requested month as a representative date to resolve payroll cycle
                const targetDate = new Date(baseYear, baseMonth - 1, 15);
                const periodInfo = await dateCycleService.getPeriodInfo(targetDate);
                const cycleMonth = periodInfo.payrollCycle.month; // 1â€“12

                const monthIndex = Math.min(Math.max(cycleMonth, 1), 12);
                const remainingMonths = Math.max(0, 12 - monthIndex); // months AFTER the current payroll month

                // Compute pending CL days in this payroll month to "lock" against monthly limit
                const Leave = require('../model/Leave');
                for (const entry of groupedData) {
                    if (!entry.casualLeave) continue;
                    const balance = Number(entry.casualLeave.balance) || 0;
                    const monthlyLimit = Math.max(0, balance - remainingMonths);

                    const empId = entry.employee?.id || entry.employee?._id;
                    const empNo = entry.employee?.empNo;
                    let pendingCLDays = 0;

                    if (empId || empNo) {
                        const empFilter = empId ? { employeeId: empId } : { emp_no: empNo };
                        const startOfCycle = periodInfo.payrollCycle.startDate;
                        const endOfCycle = periodInfo.payrollCycle.endDate;
                        const pendingLeaves = await Leave.find({
                            ...empFilter,
                            leaveType: 'CL',
                            fromDate: { $lte: endOfCycle },
                            toDate: { $gte: startOfCycle },
                            status: { $in: ['pending', 'hod_approved', 'manager_approved', 'hr_approved'] },
                            isActive: true
                        }).select('numberOfDays').lean();
                        pendingCLDays = pendingLeaves.reduce((sum, l) => sum + (l.numberOfDays || 0), 0);
                    }

                    const allowedRemaining = Math.max(0, monthlyLimit - pendingCLDays);
                    entry.casualLeave.allowedRemaining = allowedRemaining;
                    entry.casualLeave.pendingThisMonth = pendingCLDays;
                    entry.casualLeave.monthlyCLLimit = monthlyLimit;
                }
            }

            // When querying for a month without restricting to a single employee, ensure all active employees
            // in scope (division/department) are represented, even if they have no transactions in that month.
            if (!filters.balanceAsOf && !filters.employeeId && !filters.empNo && month && year) {
                const existingIds = new Set(
                    groupedData
                        .map((entry) => entry.employee && (entry.employee.id || entry.employee._id))
                        .filter(Boolean)
                        .map((id) => id.toString())
                );

                const empQuery = { is_active: true };
                if (filters.divisionId) empQuery.division_id = filters.divisionId;
                if (filters.departmentId) empQuery.department_id = filters.departmentId;

                const extraEmployees = await Employee.find(empQuery)
                    .select('_id emp_no employee_name designation_id department_id division_id doj is_active casualLeaves paidLeaves compensatoryOffs')
                    .populate('designation_id', 'name')
                    .populate('department_id', 'name')
                    .populate('division_id', 'name')
                    .lean();

                for (const emp of extraEmployees) {
                    const idStr = emp._id.toString();
                    if (existingIds.has(idStr)) continue;

                    const clBalance = typeof emp.casualLeaves === 'number' ? emp.casualLeaves : 0;
                    const elBalance = typeof emp.paidLeaves === 'number' ? emp.paidLeaves : 0;
                    const cclBalance = typeof emp.compensatoryOffs === 'number' ? emp.compensatoryOffs : 0;

                    groupedData.push({
                        employee: {
                            id: emp._id,
                            empNo: emp.emp_no,
                            name: emp.employee_name,
                            designation: emp.designation_id?.name || 'N/A',
                            department: emp.department_id?.name || 'N/A',
                            division: emp.division_id?.name || 'N/A',
                            doj: emp.doj,
                            status: emp.is_active ? 'active' : 'inactive'
                        },
                        casualLeave: {
                            openingBalance: 0,
                            accruedThisMonth: 0,
                            earnedCCL: 0,
                            usedThisMonth: 0,
                            expired: 0,
                            balance: clBalance,
                            carryForward: 0
                        },
                        earnedLeave: {
                            openingBalance: 0,
                            accruedThisMonth: 0,
                            usedThisMonth: 0,
                            balance: elBalance
                        },
                        compensatoryOff: {
                            openingBalance: 0,
                            earned: 0,
                            used: 0,
                            expired: 0,
                            balance: cclBalance
                        },
                        totalPaidBalance: clBalance + elBalance + cclBalance
                    });
                }
            }

            return groupedData;
        } catch (error) {
            console.error('Error getting leave register:', error);
            throw error;
        }
    }

    /**
     * Get employee leave ledger
     */
    async getEmployeeLedger(employeeId, leaveType, startDate, endDate) {
        try {
            const ledger = await LeaveRegister.getEmployeeLedger(employeeId, leaveType, startDate, endDate);

            return {
                employeeId,
                leaveType,
                startDate,
                endDate,
                transactions: ledger,
                openingBalance: ledger.length > 0 ? ledger[0].openingBalance : 0,
                closingBalance: ledger.length > 0 ? ledger[ledger.length - 1].closingBalance : 0,
                totalCredits: ledger.filter(t => t.transactionType === 'CREDIT').reduce((sum, t) => sum + t.days, 0),
                totalDebits: ledger.filter(t => t.transactionType === 'DEBIT').reduce((sum, t) => sum + t.days, 0)
            };
        } catch (error) {
            console.error('Error getting employee ledger:', error);
            throw error;
        }
    }

    /**
     * Get employee's complete leave register
     */
    async getEmployeeRegister(employeeId) {
        try {
            const employee = await Employee.findById(employeeId)
                .select('_id emp_no employee_name designation_id department_id division_id doj is_active')
                .populate('designation_id', 'name')
                .populate('department_id', 'name')
                .populate('division_id', 'name')
                .lean();
            if (!employee) {
                throw new Error('Employee not found');
            }

            const designation = (employee.designation_id && employee.designation_id.name) || 'N/A';
            const department = (employee.department_id && employee.department_id.name) || 'N/A';
            const divisionName = (employee.division_id && employee.division_id.name) || 'N/A';

            // Get all leave transactions for this employee
            const allTransactions = await LeaveRegister.find({ employeeId })
                .sort({ createdAt: 1 })
                .lean();

            // Group by leave type
            const leaveTypes = {};

            allTransactions.forEach(transaction => {
                const leaveType = transaction.leaveType;

                if (!leaveTypes[leaveType]) {
                    leaveTypes[leaveType] = {
                        openingBalance: 0,
                        closingBalance: 0,
                        credits: 0,
                        debits: 0,
                        transactions: []
                    };
                }

                leaveTypes[leaveType].transactions.push(transaction);
                leaveTypes[leaveType].closingBalance = transaction.closingBalance;

                if (transaction.transactionType === 'CREDIT') {
                    leaveTypes[leaveType].credits += transaction.days;
                } else if (transaction.transactionType === 'DEBIT') {
                    leaveTypes[leaveType].debits += transaction.days;
                }

                if (leaveTypes[leaveType].transactions.length === 1) {
                    leaveTypes[leaveType].openingBalance = transaction.openingBalance;
                }
            });

            return {
                employeeId: employee._id,
                empNo: employee.emp_no,
                employeeName: employee.employee_name || 'N/A',
                designation,
                department,
                divisionName,
                dateOfJoining: employee.doj,
                employmentStatus: employee.is_active ? 'active' : 'inactive',
                leaveTypes
            };
        } catch (error) {
            console.error('Error getting employee register:', error);
            throw error;
        }
    }

    /**
     * Get current balance for employee
     */
    async getCurrentBalance(employeeId, leaveType, asOfDate = new Date()) {
        try {
            const balance = await LeaveRegister.getEmployeeBalance(employeeId, leaveType, asOfDate);
            return balance ? balance.closingBalance : 0;
        } catch (error) {
            console.error('Error getting current balance:', error);
            throw error;
        }
    }

    /**
     * Helper methods
     */
    calculateClosingBalance(openingBalance, transactionData) {
        const { transactionType, days } = transactionData;

        if (transactionType === 'CREDIT') {
            return openingBalance + days;
        } else if (transactionType === 'DEBIT' || transactionType === 'EXPIRY') {
            return Math.max(0, openingBalance - days);
        } else if (transactionType === 'ADJUSTMENT') {
            return days; // For adjustments, set directly
        }
        return openingBalance;
    }

    /**
     * Group transactions by employee with monthly summary breakdown
     */
    groupByEmployeeMonthly(transactions, month, year) {
        const grouped = {};

        transactions.forEach(transaction => {
            const employeeId = transaction.employeeId._id || transaction.employeeId.id || transaction.employeeId;
            const key = employeeId.toString();

            if (!grouped[key]) {
                const emp = transaction.employeeId;
                grouped[key] = {
                    employee: {
                        id: employeeId,
                        empNo: transaction.empNo,
                        name: transaction.employeeName,
                        designation: transaction.designation,
                        department: transaction.department,
                        division: transaction.divisionName,
                        doj: transaction.dateOfJoining,
                        status: transaction.employmentStatus
                    },
                    casualLeave: { openingBalance: 0, accruedThisMonth: 0, earnedCCL: 0, usedThisMonth: 0, expired: 0, balance: 0, carryForward: 0 },
                    earnedLeave: { openingBalance: 0, accruedThisMonth: 0, usedThisMonth: 0, balance: 0 },
                    compensatoryOff: { openingBalance: 0, earned: 0, used: 0, expired: 0, balance: 0 },
                    totalPaidBalance: 0
                };
            }

            const leaveType = transaction.leaveType;
            const type = transaction.transactionType;
            const days = transaction.days;

            if (leaveType === 'CL') {
                const cl = grouped[key].casualLeave;
                if (cl.openingBalance === 0) cl.openingBalance = transaction.openingBalance;
                cl.balance = transaction.closingBalance;

                if (type === 'CREDIT') {
                    if (transaction.autoGeneratedType === 'INITIAL_BALANCE') cl.accruedThisMonth += days;
                    else if (transaction.reason?.includes('CCL')) cl.earnedCCL += days;
                    else cl.accruedThisMonth += days;
                } else if (type === 'DEBIT') {
                    cl.usedThisMonth += days;
                } else if (type === 'EXPIRY') {
                    cl.expired += days;
                } else if (type === 'CARRY_FORWARD') {
                    cl.carryForward += days;
                }
            } else if (leaveType === 'EL') {
                const el = grouped[key].earnedLeave;
                if (el.openingBalance === 0) el.openingBalance = transaction.openingBalance;
                el.balance = transaction.closingBalance;

                if (type === 'CREDIT') el.accruedThisMonth += days;
                else if (type === 'DEBIT') el.usedThisMonth += days;
            } else if (leaveType === 'CCL') {
                const ccl = grouped[key].compensatoryOff;
                if (ccl.openingBalance === 0) ccl.openingBalance = transaction.openingBalance;
                ccl.balance = transaction.closingBalance;

                if (type === 'CREDIT') ccl.earned += days;
                else if (type === 'DEBIT') ccl.used += days;
                else if (type === 'EXPIRY') ccl.expired += days;
            }
        });

        // Finalize balances and totals
        Object.values(grouped).forEach(entry => {
            entry.totalPaidBalance = entry.casualLeave.balance + entry.earnedLeave.balance + entry.compensatoryOff.balance;
        });

        return Object.values(grouped);
    }

    async updateEmployeeBalance(employeeId, leaveType) {
        try {
            const currentBalance = await this.getCurrentBalance(employeeId, leaveType);

            // Update employee model based on leave type
            const updateField = this.getEmployeeBalanceField(leaveType);
            await Employee.findByIdAndUpdate(employeeId, {
                [updateField]: currentBalance
            });
        } catch (error) {
            console.error('Error updating employee balance:', error);
            // Don't throw error here as it's not critical
        }
    }

    getEmployeeBalanceField(leaveType) {
        // EL (Earned Leave) is stored in Employee.paidLeaves for legacy naming
        const fieldMap = {
            'EL': 'paidLeaves',
            'CL': 'casualLeaves',
            'SL': 'sickLeaves',
            'ML': 'maternityLeaves',
            'OD': 'onDutyLeaves',
            'CCL': 'compensatoryOffs'
        };
        return fieldMap[leaveType] || 'paidLeaves';
    }
}

module.exports = new LeaveRegisterService();
