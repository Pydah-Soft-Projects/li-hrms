const LeaveRegister = require('../model/LeaveRegister');
const Employee = require('../../employees/model/Employee');
const Leave = require('../model/Leave');
const dateCycleService = require('./dateCycleService');

/**
 * Leave Register Service
 * Manages complete ledger of all leave transactions with audit transparency
 */

class LeaveRegisterService {
    /**
     * Add leave transaction to register
     */
    async addTransaction(transactionData) {
        try {
            // Get period info for the transaction date
            const periodInfo = await dateCycleService.getPeriodInfo(transactionData.startDate);
            
            // Get previous balance for this employee and leave type
            const previousEntry = await LeaveRegister.getEmployeeBalance(
                transactionData.employeeId, 
                transactionData.leaveType,
                transactionData.startDate
            );
            
            const openingBalance = previousEntry ? previousEntry.closingBalance : 0;
            
            // Create new transaction with proper period info
            const transaction = new LeaveRegister({
                ...transactionData,
                openingBalance,
                closingBalance: this.calculateClosingBalance(openingBalance, transactionData),
                // Use payroll cycle month/year instead of calendar
                month: periodInfo.payrollCycle.month,
                year: periodInfo.payrollCycle.year,
                financialYear: periodInfo.financialYear.name,
                // Store period details for reference
                payrollCycleStart: periodInfo.payrollCycle.startDate,
                payrollCycleEnd: periodInfo.payrollCycle.endDate,
                financialYearStart: periodInfo.financialYear.startDate,
                financialYearEnd: periodInfo.financialYear.endDate
            });
            
            const savedTransaction = await transaction.save();
            
            // Update employee leave balance in employee model
            await this.updateEmployeeBalance(transactionData.employeeId, transactionData.leaveType);
            
            return savedTransaction;
        } catch (error) {
            console.error('Error adding leave transaction:', error);
            throw error;
        }
    }

    /**
     * Add earned leave credit (auto-generated)
     */
    async addEarnedLeaveCredit(employeeId, elEarned, month, year, calculationBreakdown = null) {
        try {
            const employee = await Employee.findById(employeeId);
            if (!employee) {
                throw new Error('Employee not found');
            }

            // Get payroll cycle info for the given month/year
            const cycleDate = new Date(year, month - 1, 15); // Middle of month to get correct cycle
            const periodInfo = await dateCycleService.getPeriodInfo(cycleDate);

            const transactionData = {
                employeeId,
                empNo: employee.emp_no,
                employeeName: employee.name,
                designation: employee.designation || 'N/A',
                department: employee.department || 'N/A',
                divisionId: employee.division_id,
                departmentId: employee.department_id,
                dateOfJoining: employee.date_of_joining,
                employmentStatus: employee.is_active ? 'active' : 'inactive',
                
                leaveType: 'EL',
                transactionType: 'CREDIT',
                startDate: periodInfo.payrollCycle.startDate,
                endDate: periodInfo.payrollCycle.startDate,
                days: elEarned,
                reason: 'Earned Leave - Auto Credit',
                status: 'APPROVED',
                
                // Use payroll cycle period info
                month: periodInfo.payrollCycle.month,
                year: periodInfo.payrollCycle.year,
                financialYear: periodInfo.financialYear.name,
                autoGenerated: true,
                autoGeneratedType: 'EARNED_LEAVE',
                calculationBreakdown,
                
                // Store period details
                payrollCycleStart: periodInfo.payrollCycle.startDate,
                payrollCycleEnd: periodInfo.payrollCycle.endDate,
                financialYearStart: periodInfo.financialYear.startDate,
                financialYearEnd: periodInfo.financialYear.endDate
            };

            return await this.addTransaction(transactionData);
        } catch (error) {
            console.error('Error adding earned leave credit:', error);
            throw error;
        }
    }

    /**
     * Add leave debit (when leave is availed)
     */
    async addLeaveDebit(leaveRecord) {
        try {
            const employee = await Employee.findById(leaveRecord.employeeId);
            if (!employee) {
                throw new Error('Employee not found');
            }

            const transactionData = {
                employeeId: leaveRecord.employeeId,
                empNo: employee.emp_no,
                employeeName: employee.name,
                designation: employee.designation || 'N/A',
                department: employee.department || 'N/A',
                divisionId: employee.division_id,
                departmentId: employee.department_id,
                dateOfJoining: employee.date_of_joining,
                employmentStatus: employee.is_active ? 'active' : 'inactive',
                
                leaveType: leaveRecord.leaveType,
                transactionType: 'DEBIT',
                startDate: leaveRecord.fromDate,
                endDate: leaveRecord.toDate,
                days: leaveRecord.numberOfDays,
                applicationId: leaveRecord._id,
                applicationDate: leaveRecord.createdAt,
                approvalDate: leaveRecord.updatedAt, // Use updatedAt as approval date
                approvedBy: leaveRecord.workflow?.currentStepRole || 'system',
                status: leaveRecord.status,
                reason: leaveRecord.purpose
            };

            return await this.addTransaction(transactionData);
        } catch (error) {
            console.error('Error adding leave debit:', error);
            throw error;
        }
    }

    /**
     * Get leave register with filters
     */
    async getLeaveRegister(filters = {}, month = null, year = null) {
        try {
            const registerData = await LeaveRegister.getLeaveRegister(filters, month, year);
            
            // Populate employee details for all transactions
            const populatedData = await Promise.all(
                registerData.map(async (transaction) => {
                    if (transaction.employeeId && typeof transaction.employeeId === 'object') {
                        // If employeeId is already populated, use it
                        return transaction;
                    } else {
                        // Populate employee details
                        const employee = await Employee.findById(transaction.employeeId)
                            .select('employee_name emp_no designation_id department_id division_id doj is_active')
                            .populate('designation_id', 'name')
                            .populate('department_id', 'name')
                            .populate('division_id', 'name');
                        
                        if (employee) {
                            transaction.employeeId = employee;
                            transaction.employeeName = employee.employee_name;
                            transaction.designation = employee.designation_id?.name || 'N/A';
                            transaction.department = employee.department_id?.name || 'N/A';
                            transaction.divisionName = employee.division_id?.name || 'N/A';
                            transaction.dateOfJoining = employee.doj;
                            transaction.employmentStatus = employee.is_active ? 'active' : 'inactive';
                        }
                    }
                    return transaction;
                })
            );
            
            // Group by employee for better display
            const groupedData = this.groupByEmployee(populatedData);
            
            return groupedData;
        } catch (error) {
            console.error('Error getting leave register:', error);
            throw error;
        }
    }

    /**
     * Get employee leave ledger
     */
    async getEmployeeLedger(employeeId, leaveType, startDate, endDate) {
        try {
            const ledger = await LeaveRegister.getEmployeeLedger(employeeId, leaveType, startDate, endDate);
            
            return {
                employeeId,
                leaveType,
                startDate,
                endDate,
                transactions: ledger,
                openingBalance: ledger.length > 0 ? ledger[0].openingBalance : 0,
                closingBalance: ledger.length > 0 ? ledger[ledger.length - 1].closingBalance : 0,
                totalCredits: ledger.filter(t => t.transactionType === 'CREDIT').reduce((sum, t) => sum + t.days, 0),
                totalDebits: ledger.filter(t => t.transactionType === 'DEBIT').reduce((sum, t) => sum + t.days, 0)
            };
        } catch (error) {
            console.error('Error getting employee ledger:', error);
            throw error;
        }
    }

    /**
     * Get employee's complete leave register
     */
    async getEmployeeRegister(employeeId) {
        try {
            const employee = await Employee.findById(employeeId);
            if (!employee) {
                throw new Error('Employee not found');
            }

            // Get all leave transactions for this employee
            const allTransactions = await LeaveRegister.find({ employeeId })
                .sort({ createdAt: 1 });

            // Group by leave type
            const leaveTypes = {};
            
            allTransactions.forEach(transaction => {
                const leaveType = transaction.leaveType;
                
                if (!leaveTypes[leaveType]) {
                    leaveTypes[leaveType] = {
                        openingBalance: 0,
                        closingBalance: 0,
                        credits: 0,
                        debits: 0,
                        transactions: []
                    };
                }
                
                leaveTypes[leaveType].transactions.push(transaction);
                leaveTypes[leaveType].closingBalance = transaction.closingBalance;
                
                if (transaction.transactionType === 'CREDIT') {
                    leaveTypes[leaveType].credits += transaction.days;
                } else if (transaction.transactionType === 'DEBIT') {
                    leaveTypes[leaveType].debits += transaction.days;
                }
                
                // Set opening balance from first transaction
                if (leaveTypes[leaveType].transactions.length === 1) {
                    leaveTypes[leaveType].openingBalance = transaction.openingBalance;
                }
            });

            return {
                employeeId: employee._id,
                empNo: employee.emp_no,
                employeeName: employee.name,
                designation: employee.designation || 'N/A',
                department: employee.department || 'N/A',
                divisionName: 'N/A', // TODO: Populate from division
                dateOfJoining: employee.date_of_joining,
                employmentStatus: employee.is_active ? 'active' : 'inactive',
                leaveTypes
            };
        } catch (error) {
            console.error('Error getting employee register:', error);
            throw error;
        }
    }

    /**
     * Get current balance for employee
     */
    async getCurrentBalance(employeeId, leaveType, asOfDate = new Date()) {
        try {
            const balance = await LeaveRegister.getEmployeeBalance(employeeId, leaveType, asOfDate);
            return balance ? balance.closingBalance : 0;
        } catch (error) {
            console.error('Error getting current balance:', error);
            throw error;
        }
    }

    /**
     * Helper methods
     */
    calculateClosingBalance(openingBalance, transactionData) {
        const { transactionType, days } = transactionData;
        
        if (transactionType === 'CREDIT') {
            return openingBalance + days;
        } else if (transactionType === 'DEBIT') {
            return Math.max(0, openingBalance - days);
        } else if (transactionType === 'ADJUSTMENT') {
            return days; // For adjustments, set directly
        }
        return openingBalance;
    }

    groupByEmployee(transactions) {
        const grouped = {};
        
        transactions.forEach(transaction => {
            // Extract employee ID properly - handle both string and object cases
            const employeeId = transaction.employeeId._id || transaction.employeeId.id || transaction.employeeId;
            const key = employeeId.toString();
            
            if (!grouped[key]) {
                grouped[key] = {
                    employeeId: employeeId, // Store as string ID
                    empNo: transaction.empNo,
                    employeeName: transaction.employeeName,
                    designation: transaction.designation,
                    department: transaction.department,
                    divisionId: transaction.divisionId,
                    departmentId: transaction.departmentId,
                    dateOfJoining: transaction.dateOfJoining,
                    employmentStatus: transaction.employmentStatus,
                    leaveTypes: {}
                };
            }
            
            const leaveType = transaction.leaveType;
            if (!grouped[key].leaveTypes[leaveType]) {
                grouped[key].leaveTypes[leaveType] = {
                    openingBalance: 0,
                    closingBalance: 0,
                    credits: 0,
                    debits: 0,
                    transactions: []
                };
            }
            
            grouped[key].leaveTypes[leaveType].transactions.push(transaction);
            grouped[key].leaveTypes[leaveType].openingBalance = Math.max(
                grouped[key].leaveTypes[leaveType].openingBalance,
                transaction.openingBalance
            );
            grouped[key].leaveTypes[leaveType].closingBalance = transaction.closingBalance;
            
            if (transaction.transactionType === 'CREDIT') {
                grouped[key].leaveTypes[leaveType].credits += transaction.days;
            } else if (transaction.transactionType === 'DEBIT') {
                grouped[key].leaveTypes[leaveType].debits += transaction.days;
            }
        });
        
        return Object.values(grouped);
    }

    async updateEmployeeBalance(employeeId, leaveType) {
        try {
            const currentBalance = await this.getCurrentBalance(employeeId, leaveType);
            
            // Update employee model based on leave type
            const updateField = this.getEmployeeBalanceField(leaveType);
            await Employee.findByIdAndUpdate(employeeId, {
                [updateField]: currentBalance
            });
        } catch (error) {
            console.error('Error updating employee balance:', error);
            // Don't throw error here as it's not critical
        }
    }

    getEmployeeBalanceField(leaveType) {
        const fieldMap = {
            'EL': 'paidLeaves',
            'CL': 'casualLeaves',
            'SL': 'sickLeaves',
            'ML': 'maternityLeaves',
            'OD': 'onDutyLeaves',
            'CCL': 'compensatoryOffs'
        };
        return fieldMap[leaveType] || 'paidLeaves';
    }
}

module.exports = new LeaveRegisterService();
